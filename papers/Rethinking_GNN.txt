Title: RETHINKING THE EXPRESSIVE POWER OF GNNS VIA GRAPH BICONNECTIVITY

ABSTRACT
 Designing expressive Graph Neural Networks (GNNs) is a central topic in learning graph-structured data. While numerous approaches have been proposed to improve GNNs in terms of the Weisfeiler-Lehman (WL) test, generally there is still a lack of deep understanding of what additional power they can systematically and provably gain. In this paper, we take a fundamentally different perspective to study the expressive power of GNNs beyond the WL test. Specifically, we introduce a novel class of expressivity metrics via graph biconnectivity and highlight their importance in both theory and practice. As biconnectivity can be easily calculated using simple algorithms that have linear computational costs, it is natural to expect that popular GNNs can learn it easily as well. However, after a thorough review of prior GNN architectures, we surprisingly find that most of them are not expressive for any of these metrics. The only exception is the ESAN framework (Bevilacqua et al., 2022), for which we give a theoretical justification of its power. We proceed to introduce a principled and more efficient approach, called the Generalized Distance Weisfeiler-Lehman (GD-WL), which is provably expressive for all biconnectivity metrics. Practically, we show GD-WL can be implemented by a Transformer-like architecture that preserves expressiveness and enjoys full parallelizability. A set of experiments on both synthetic and real datasets demonstrates that our approach can consistently outperform prior GNN architectures.

1	INTRODUCTION
Graph neural networks (GNNs) have recently become the dominant approach for graph representation learning. Among numerous architectures, message-passing neural networks (MPNNs) are arguably the most popular design paradigm and have achieved great success in various fields (Gilmer et al., 2017; Hamilton et al., 2017; Kipf & Welling, 2017; Velickoviˇ c et al.´ , 2018). However, one major drawback of MPNNs lies in the limited expressiveness: as pointed out by Xu et al. (2019); Morris et al. (2019), they can never be more powerful than the classic 1-dimensional WeisfeilerLehman (1-WL) test in distinguishing non-isomorphic graphs (Weisfeiler & Leman, 1968). This inspired a variety of works to design provably more powerful GNNs that go beyond the 1-WL test.
One line of subsequent works aimed to propose GNNs that match the higher-order WL variants (Morris et al., 2019; 2020; Maron et al., 2019c;a; Geerts & Reutter, 2022). While being highly expressive, such an approach suffers from severe computation/memory costs. Moreover, there have been concerns about whether the achieved expressiveness is necessary for real-world tasks (Velickoviˇ c´, 2022). In light of this, other recent works sought to develop new GNN architectures with improved expressiveness while still keeping the message-passing framework for efficiency (Bouritsas et al., 2022; Bodnar et al., 2021b;a; Bevilacqua et al., 2022; Wijesinghe & Wang, 2022, and see Appendix A for more recent advances). However, most of these works mainly justify their expressiveness by giving toy examples where WL algorithms fail to distinguish, e.g., by focusing on regular graphs. On the theoretical side, it is quite unclear what additional power they can systematically and provably gain. More fundamentally, to the best of our knowledge (see Appendix D.1), there is still a lack of principled and convincing metrics beyond the WL hierarchy to formally measure the expressive power and to guide the design of provably better GNN architectures
In this paper, we systematically study the problem of designing expressive GNNs from a novel perspective of graph biconnectivity. Biconnectivity has long been a central topic in graph theory (Bollobas´ , 1998). It comprises a series of important concepts such as cut vertex (articulation point), cut edge (bridge), biconnected component, and block cut tree (see Section 2 for formal definitions). Intuitively, biconnectivity provides a structural description of a graph by decomposing it into disjoint sub-components and linking them via cut vertices/edges to form a tree structure (cf. Figure 1(b,c)). As can be seen, biconnectivity purely captures the intrinsic structure of a graph.
The significance of graph biconnectivity can be reflected in various aspects. Firstly, from a theoretical point of view, it is a basic graph property and is linked to many fundamental topics in graph theory, ranging from path-related problems to network flow (Granot & Veinott Jr, 1985) and spanning trees (Kapoor & Ramesh, 1995), and is highly relevant to planar graph isomorphism (Hopcroft & Tarjan, 1972). Secondly, from a practical point of view, cut vertices/edges have substantial values in many real applications. For example, chemical reactions are highly related to edge-biconnectivity of the molecule graph, where the breakage of molecular bonds usually occurs at the cut edges and each biconnected component often remains unchanged after the reaction. As another example, social networks are related to vertex-biconnectivity, where cut vertices play an important role in linking between different groups of people (biconnected components). Finally, from a computational point of view, the problems related to biconnectivity (e.g., finding cut vertices/edges or constructing block cut trees) can all be efficiently solved using classic algorithms (Tarjan, 1972), with a computation complexity equal to graph size (which is the same as an MPNN). Therefore, one may naturally expect that popular GNNs should be able to learn all things related to biconnectivity without difficulty.
Unfortunately, we show this is not the case. After a thorough analysis of four classes of representative GNN architectures in literature (see Section 3.1), we find that surprisingly, none of them could even solve the easiest biconnectivity problem: to distinguish whether a graph has cut vertices/edges or not (corresponding to a graph-level binary classification). As a result, they obviously failed in the following harder tasks: (i) identifying all cut vertices (a node-level task); (ii) identifying all cut edges (an edge-level task); (iii) the graph-level task for general biconnectivity problems, e.g., distinguishing a pair of graphs that have non-isomorphic block cut trees. This raises the following question: can we design GNNs with provable expressiveness for biconnectivity problems?
We first give an affirmative answer to the above question. By conducting a deep analysis of the recently proposed Equivariant Subgraph Aggregation Network (ESAN) (Bevilacqua et al., 2022), we prove that the DSS-WL algorithm with node marking policy can precisely identify both cut vertices and cut edges. This provides a new understanding as well as a strong theoretical justification for the expressive power of DSS-WL and its recent extensions (Frasca et al., 2022). Furthermore, we give a fine-grained analysis of several key factors in the framework, such as the graph generation policy and the aggregation scheme, by showing that neither (i) the ego-network policy without marking nor (ii) a variant of the weaker DS-WL algorithm can identify cut vertices.
However, GNNs designed based on DSS-WL are usually sophisticated and suffer from high computation/memory costs. The main contribution in this paper is then to give a principled and efficient way to design GNNs that are expressive for biconnectivity problems. Targeting this question, we restart from the classic 1-WL algorithm and figure out a major weakness in distinguishing biconnectivity: the lack of distance information between nodes. Indeed, the importance of distance information is theoretically justified in our proof for analyzing the expressive power of DSS-WL. To this end, we introduce a novel color refinement framework, formalized as Generalized Distance
Weisfeiler-Lehman (GD-WL), by directly encoding a general distance metric into the WL aggregation procedure. We first prove that as a special case, the Shortest Path Distance WL (SPD-WL) is expressive for all edge-biconnectivity problems, thus providing a novel understanding of its empirical success. However, it still cannot identify cut vertices. We further suggest an alternative called the Resistance Distance WL (RD-WL) for vertex-biconnectivity. To sum up, all biconnectivity problems can be provably solved within our proposed GD-WL framework.
Finally, we give a worst-case analysis of the proposed GD-WL framework. We discuss its limitations by proving that the expressive power of both SPD-WL and RD-WL can be bounded by the standard 2-FWL test (Cai et al., 1992). Consequently, 2-FWL is fully expressive for all biconnectivity metrics. Besides, since GD-WL heavily relies on distance information, we proceed to analyze its power in distinguishing the class of distance-regular graphs (Brouwer et al., 1989). Surprisingly, we show GD-WL matches the power of 2-FWL in this case, which strongly justifies its high expressiveness in distinguishing hard graphs. A summary of our theoretical contributions is given in Table 1.
Practical Implementation. The main advantage of GD-WL lies in its simplicity, efficiency and parallelizability. We show it can be easily implemented using a Transformer-like architecture by injecting the distance into Multi-head Attention (Vaswani et al., 2017), similar to Ying et al. (2021a). Importantly, we prove that the resulting Graph Transformer (called Graphormer-GD) is as expressive as GD-WL. This offers strong theoretical insights into the power and limits of Graph Transformers. Empirically, we show Graphormer-GD not only achieves perfect accuracy in detecting cut vertices and cut edges, but also outperforms prior GNN achitectures on popular benchmark datasets.


2	PRELIMINARY
Notations. We use { } to denote sets and use {{ }} to denote multisets. The cardinality of (multi)set S is denoted as |S|. The index set is denoted as [n] := {1,··· ,n}. Throughout this paper, we consider simple undirected graphs G = (V,E) with no repeated edges or self-loops. Therefore, each edge {u,v} ∈ E can be expressed as a set of two elements. For a node u ∈ V, denote its neighbors as NG(u) := {v ∈ V : {u,v} ∈ E} and denote its degree as degG(u) := |NG(u)|. A path P = (u0,··· ,ud) is a tuple of nodes satisfying {ui−1,ui} ∈ E for all i ∈ [d], and its length is denoted as |P| := d. A path P is said to be simple if it does not go through a node more than once, i.e. ui ̸= uj for i ̸= j. The shortest path distance between two nodes u and v is denoted to be disG(u,v) := min{|P| : P is a path from u to v}. The induced subgraph with vertex subset S ⊂ V is defined as G[S] = (S,ES) where ES := {{u,v} ∈ E : u,v ∈ S}.
We next introduce the concepts of connectivity, vertex-biconnectivity and edge-biconnectivity.
Definition 2.1. (Connectivity) A graph G is connected if for any two nodes u,v ∈ V, there is a path from u to v. A vertex set S ⊂ V is a connected component of G if G[S] is connected and for any proper superset T ⊋ S, G[T ] is disconnected. Denote CC(G) as the set of all connected components, then CC(G) forms a partition of the vertex set V. Clearly, G is connected iff |CC(G)| = 1.
Definition 2.2. (Biconnectivity) A node v ∈ V is a cut vertex (or articulation point) of G if removing v increases the number of connected components, i.e., |CC(G[V\{v}])| > |CC(G)|. A graph is vertex-biconnected if it is connected and does not have any cut vertex. A vertex set S ⊂ V is a vertex-biconnected component of G if G[S] is vertex-biconnected and for any proper superset T ⊋ S, G[T ] is not vertex-biconnected. We can similarly define the concepts of cut edge (or bridge) and edge-biconnected component (we omit them for brevity). Finally, denote BCCV(G) (resp. BCCE(G)) as the set of all vertex-biconnected (resp. edge-biconnected) components.
Two non-adjacent nodes u,v ∈ V are in the same vertex-biconnected component iff there are two paths from u to v that do not intersect (except at endpoints). Two nodes u,v are in the same edgebiconnected component iff there are two paths from u to v that do not share an edge. On the other hand, if two nodes are in different vertex/edge-biconnected components, any path between them must go through some cut vertex/edge. Therefore, cut vertices/edges can be regarded as “hubs” in a graph that link different subgraphs into a whole. Furthermore, the link between cut vertices/edges and biconnected components forms a tree structure, which are called the block cut tree (cf. Figure 1).
Definition 2.3. (Block cut-edge tree) The block cut-edge tree of graph G = (V,E) is defined as follows: BCETree(G) := (BCCE(G),EE), where
  BCCE  .
Definition 2.4. (Block cut-vertex tree) The block cut-vertex tree of graph G = (V,E) is defined as follows: BCVTree(G) := (BCCV(G) ∪ VCut,EV), where VCut ⊂ V is the set containing all cut vertices of G and
 BCCV .
The following theorem shows that all concepts related to biconnectivity can be efficiently computed.
Theorem 2.5. (Tarjan, 1972) The problems related to biconnectivity, including identifying all cut vertices/edges, finding all biconnected components (BCCV(G) and BCCE(G)), and building block cut trees (BCVTree(G) and BCETree(G)), can all be solved using the Depth-First Search algorithm, within a computation complexity linear in the graph size, i.e. Θ(|V| + |E|).
Isomorphism and color refinement algorithms. Two graphs G = (VG,EG) and H = (VH,EH) are isomorphic (denoted as G ≃ H) if there is an isomorphism (bijective mapping) f : VG → VH such that for any nodes u,v ∈ VG, {u,v} ∈ EG iff {f(u),f(v)} ∈ EH. A color refinement algorithm is an algorithm that outputs a color mapping χG : VG → C when taking graph G as input, where C is called the color set. A valid color refinement algorithm must preserve invariance under isomorphism, i.e., χG(u) = χH(f(u)) for isomorphism f and node u ∈ VG. As a result, it can be used as a necessary test for graph isomorphism by comparing the multisets {{χG(u) : u ∈ VG}} and {{χH(u) : u ∈ VH}}, which we call the graph representations. Similarly, χG(u) can be seen as the node feature of u ∈ VG, and {{χG(u),χG(v)}} corresponds to the edge feature of {u,v} ∈ EG. All algorithms studied in this paper fit the color refinement framework, and please refer to Appendix B for a precise description of several representatives (e.g., the classic 1-WL and k-FWL algorithms).
Problem setup. This paper focuses on the following three types of problems with increasing difficulties. Firstly, we say a color refinement algorithm can distinguish whether a graph is vertex/edgebiconnected, if for any graphs G,H where G is vertex/edge-biconnected but H is not, their graph representations are different, i.e. {{χG(u) : u ∈ VG}} ̸= {{χH(u) : u ∈ VH}}. Secondly, we say a color refinement algorithm can identify cut vertices if for any graphs G,H and nodes u ∈ VG,v ∈ VH where u is a cut vertex but v is not, their node features are different, i.e. χG(u) ̸= χH(v). Similarly, it can identify cut edges if for any {u,v} ∈ EG and {w,x} ∈ EH where {u,v} is a cut edge but {w,x} is not, their edge features are different, i.e. {{χG(u),χG(v)}} ̸= {{χH(w),χH(x)}}. Finally, we say a color refinement algorithm can distinguish block cut-vertex/edge trees, if for any graphs G,H satisfying BCVTree(G) ̸≃ BCVTree(H) (or BCETree(G) ̸≃ BCETree(H)), their graph representations are different, i.e. {{χG(u) : u ∈ VG}} ̸= {{χH(u) : u ∈ VH}}.

3	INVESTIGATING KNOWN GNN ARCHITECTURES VIA BICONNECTIVITY
In this section, we provide a comprehensive investigation of popular GNN variants in literature, including the classic MPNNs, Graph Substructure Networks (GSN) (Bouritsas et al., 2022) and its variant (Barcelo et al.´ , 2021), GNN with lifting transformations (MPSN and CWN) (Bodnar et al., 2021b;a), GraphSNN (Wijesinghe & Wang, 2022), and Subgraph GNNs (e.g., Bevilacqua et al. (2022)). Surprisingly, we find most of these works are not expressive for any biconnectivity problems listed above. The only exceptions are the ESAN (Bevilacqua et al., 2022) and several variants, where we give a rigorous justification of their expressive power for both vertex/edge-biconnectivity.
3.1	COUNTEREXAMPLES
1-WL/MPNNs. We first consider the classic 1-WL. We provide two principled class of counterexamples which are formally defined in Examples C.9 and C.10, with a few special cases illustrated in Figure 2. For each pair of graphs in Figure 2, the color of each node is drawn according to the 1-WL color mapping. It can be seen that the two graph representations are the same. Therefore, 1-WL cannot distinguish any biconnectivity problem listed in Section 2.
Substructure Counting WL/GSN. Bouritsas et al. (2022) developed a principled approach to boost the expressiveness of MPNNs by incorporating substructure counts into node features or the 1WL aggregation procedure. The resulting algorithm, which we call the SC-WL, is detailed in Appendix B.3. However, we show no matter what sub-structures are used, the corresponding GSN still cannot solve any biconnectivity problem listed in Section 2. We give a proof in Appendix C.2 for the general case that allows arbitrary substructures, based on Examples C.9 and C.10. We also point out that our negative result applies to the similar GNN variant in Barcelo et al.´ (2021).
Theorem 3.1. Let H = {H1,··· ,Hk}, Hi = (Vi,Ei) be any set of connected graphs and denote n = maxi∈[k] |Vi|. Then SC-WL (Appendix B.3) using the substructure set H cannot solve any vertex/edge-biconnectivity problem listed in Section 2. Moreover, there exist counterexample graphs whose sizes (both in terms of vertices and edges) are O(n).
GNNs with lifting transformations (MPSN/CWN). Bodnar et al. (2021b;a) considered another approach to design powerful GNNs by using graph lifting transformations. In a nutshell, these approaches exploit higher-order graph structures such as cliques and cycles to design new WL aggregation procedures. Unfortunately, we show the resulting algorithms, called the SWL and CWL, still cannot solve any biconnectivity problem. Please see Appendix C.2 (Proposition C.12) for details.
Other GNN variants. In Appendix C.2, we discuss other recently proposed GNNs, such as GraphSNN (Wijesinghe & Wang, 2022), GNN-AK (Zhao et al., 2022), and NGNN (Zhang & Li, 2021). Due to space limit, we defer the corresponding negative results in Propositions C.13, C.15 and C.16.
3.2	PROVABLE EXPRESSIVENESS OF ESAN AND DSS-WL
We next switch our attention to a new type of GNN framework proposed in Bevilacqua et al. (2022), called the Equivariant Subgraph Aggregation Networks (ESAN). The central algorithm in EASN is called the DSS-WL. Given a graph G, DSS-WL first generates a bag of vertex-shared (sub)graphs BGπ = {{G1,··· ,Gm}} according to a graph generation policy π. Then in each iteration t, the algorithm refines the color of each node v in each subgraph Gi by jointly aggregating its neighboring colors in the own subgraph and across all subgraphs. The aggregation formula can be written as:
 ) := hash  
	 ) := hash   ,	(2)
where hash is a perfect hash function. DSS-WL terminates when χtG induces a stable vertex partition. In this paper, we consider node-based graph generation policies, for which each subgraph is associated to a specific node, i.e. BGπ = {{Gv : v ∈ V}}. Some popular choices are node deletion πND, node marking πNM, k-ego-network πEGO(k), and its node marking version πEGOM(k). A full description of DSS-WL as well as different policies can be found in Appendix B.4 (Algorithm 3).
A fundamental question regarding DSS-WL is how expressive it is. While a straightforward analysis shows that DSS-WL is strictly more powerful than 1-WL, an in-depth understanding on what additional power DSS-WL gains over 1-WL is still limited. The only new result is the very recent work of Frasca et al. (2022), who showed a 3-WL upper bound for the expressivity of DSS-WL. Yet, such a result actually gives a limitation of DSS-WL rather than showing its power. Moreover, there is a large gap between the highly strong 3-WL and the weak 1-WL. In the following, we take a different perspective and prove that DSS-WL is expressive for both types of biconnectivity problems.
Theorem 3.2. Let G = (VG,EG) and H = (VH,EH) be two graphs, and let χG and χH be the corresponding DSS-WL color mapping with node marking policy. Then the following holds:
•	For any two nodes w ∈ VG and x ∈ VH, if χG(w) = χH(x), then w is a cut vertex if and only if x is a cut vertex.
•	For any two edges {w1,w2} ∈ EG and {x1,x2} ∈ EH, if {{χG(w1),χG(w2)}} =
{{χH(x1),χH(x2)}}, then {w1,w2} is a cut edge if and only if {x1,x2} is a cut edge.
The proof of Theorem 3.2 is highly technical and is deferred to Appendix C.3. By using the basic results derived in Appendix C.1, we conduct a careful analysis of the DSS-WL color mapping and discover several important properties. They give insights on why DSS-WL can succeed in distinguishing biconnectivity, as we will discuss below.
How can DSS-WL distinguish biconnectivity? We find that a crucial advantage of DSS-WL over the classic 1-WL is that DSS-WL color mapping implicitly encodes distance information (see Lemma C.19(e) and Corollary C.24). For example, two nodes u ∈ VG,v ∈ VH will have different DSS-WL colors if the distance set {{disG(u,w) : w ∈ VG}} differs from {{disH(v,w) : w ∈ VH}}. Our proof highlights that distance information plays a vital role in distinguishing edgebiconnectivity when combining with color refinement algorithms (detailed in Section 4), and it also helps distinguish vertex-biconnectivity (see the proof of Lemma C.22). Consequently, our analysis provides a novel understanding and a strong justification for the success of DSS-WL in two aspects: the graph representation computed by DSS-WL intrinsically encodes distance and biconnectivity information, both of which are fundamental structural properties of graphs but are lacking in 1-WL.
Discussions on graph generation policies. Note that Theorem 3.2 holds for node marking policy. In fact, the ability of DSS-WL to encode distance information heavily relies on node marking as shown in the proof of Lemma C.19. In contrast, we prove that the ego-network policy πEGO(k) cannot distinguish cut vertices (Proposition C.14), using the counterexample given in Figure 2(c). Therefore, our result shows an inherent advantage of node marking than the ego-network policy in distinguishing a class of non-isomorphic graphs, which is raised as an open question in Bevilacqua et al. (2022, Section 5). It also highlights a theoretical limitation of πEGO(k) compared with its node marking version πEGOM(k), a subtle difference that may not have received sufficient attention yet. For example, both the GNN-AK and GNN-AK-ctx architecture (Zhao et al., 2022) cannot solve vertex-biconnectivity problems since it is similar to πEGO(k) (see Proposition C.15). On the other hand, the GNN-AK+ does not suffer from such a drawback although it also uses πEGO(k), because it further adds distance encoding in each subgraph (which is more expressive than node marking).
Discussions on DS-WL. Bevilacqua et al. (2022); Cotta et al. (2021) also considered a weaker version of DSS-WL, called the DS-WL, which aggregates the node color in each subgraph without interaction across different subgraphs (see formula (10)). We show in Proposition C.16 that unfortunately, DS-WL with common node-based policies cannot identify cut vertices when the color of each node v is defined as its associated subgraph representation Gv. This theoretically reveals the importance of cross-graph aggregation and justifies the design of DSS-WL. Finally, we point out that Qian et al. (2022) very recently proposed an extension of DS-WL that adds a final cross-graph aggregation procedure, for which our negative result may not hold. It may be an interesting direction to theoretically analyze the expressiveness of this type of DS-WL in future work.

4	GENERALIZED DISTANCE WEISFEILER-LEHMAN TEST
After an extensive review of prior GNN architectures, in this section we would like to formally study the following problem: can we design a principled and efficient GNN framework with provable expressiveness for biconnectivity? In fact, while in Section 3.2 we have proved that DSS-WL can solve biconnectivity problems, it is still far from enough. Firstly, the corresponding GNNs based on DSS-WL is usually sophisticated due to the complex aggregation formula (1), which inspires us to study whether simpler architectures exist. More importantly, DSS-WL suffers from high computational costs in both time and memory. Indeed, it requires Θ(n2) space and Θ(nm) time per iteration (using policy πNM) to compute node colors for a graph with n nodes and m edges, which is n times costly than 1-WL. Given the theoretical linear lower bound in Theorem 2.5, one may naturally raise the question of how to close the gap by developing more efficient color refinement algorithms.
We approach the problem by rethinking the classic 1-WL test. We argue that a major weakness of 1-WL is that it is agnostic to distance information between nodes, partly because each node can only “see” its neighbors in aggregation. On the other hand, the DSS-WL color mapping implicitly encodes distance information as shown in Section 3.2, which inspires us to formally study whether incorporating distance in the aggregation procedure is crucial for solving biconnectivity problems. To this end, we introduce a novel color refinement framework which we call Generalized Distance Weisfeiler-Lehman (GD-WL). The update rule of GD-WL is very simple and can be written as:
	χtG(v) := hash  ,	(3)
where dG can be an arbitrary distance metric. The full algorithm is described in Algorithm 4.
SPD-WL for edge-biconnectivity. As a special case, when choosing the shortest path distance dG = disG, we obtain an algorithm which we call SPD-WL. It can be equivalently written as χtG(v) := hash  
From (4) it is clear that SPD-WL is strictly more powerful than 1-WL since it additionally aggregates the k-hop neighbors for all k > 1. There have been several prior works related to SPD-WL, including using distance encoding as node features (Li et al., 2020) or performing k-hop aggregation for some small k (see Appendix D.2 for more related works and discussions). Yet, these works are either purely empirical or provide limited theoretical analysis (e.g., by focusing only on regular graphs). Instead, we introduce the general and more expressive SPD-WL framework with a rather different motivation and perform a systematic study on its expressive power. Our key result confirms that SPD-WL is fully expressive for all edge-biconnectivity problems listed in Section 2.
Theorem 4.1. Let G = (VG,EG) and H = (VH,EH) be two graphs, and let χG and χH be the corresponding SPD-WL color mapping. Then the following holds:
•	For any two edges {w1,w2} ∈ EG and {x1,x2} ∈ EH, if {{χG(w1),χG(w2)}} =
{{χH(x1),χH(x2)}}, then {w1,w2} is a cut edge if and only if {x1,x2} is a cut edge.
•	If {{χG(w) : w ∈ VG}} = {{χH(w) : w ∈ VH}}, then BCETree(G) ≃ BCETree(H).
Theorem 4.1 is highly non-trivial and perhaps surprising at first sight, as it combines three seemingly unrelated concepts (i.e., SPD, biconnectivity, and the WL test) into a unified conclusion. We give a proof in Appendix C.4, which separately considers two cases: χG(w1) ̸= χG(w2) and χG(w1) = χG(w2) (see Figure 2(b,d) for examples). For each case, the key technique in the proof is to construct an auxiliary graph (Definitions C.26 and C.34) that precisely characterizes the structural relationship between nodes that have specific colors (see Corollaries C.31 and C.40). Finally, we highlight that the second item of Theorem 4.1 may be particularly interesting: while distinguishing general nonisomorphic graphs are known to be hard (Cai et al., 1992; Babai, 2016), we show distinguishing non-isomorphic graphs with different block cut-edge trees can be much easily solved by SPD-WL.
RD-WL for vertex-biconnectivity. Unfortunately, while SPD-WL is fully expressive for edgebiconnectivity, it is not expressive for vertex-biconnectivity. We give a simple counterexample in Figure 2(c), where SPD-WL cannot distinguish the two graphs. Nevertheless, we find that by using a different distance metric, problems related to vertex-biconnectivity can also be fully solved. We propose such a choice called the Resistance Distance (RD) (denoted as disRG), which is also a basic metric in graph theory (Doyle & Snell, 1984; Klein & Randic´, 1993; Sanmartın et al., 2022). Formally, the value of disRG(u,v) is defined to be the effective resistance between nodes u and v when treating G as an electrical network where each edge corresponds to a resistance of one ohm. We note that other generalized distances can also be considered (Li et al., 2020; Velingker et al., 2022).
RD has many elegant properties. First, it is a valid metric: indeed, RD is non-negative, semidefinite, symmetric, and satisfies the triangular inequality (see Appendix E.2). Moreover, similar to SPD, we also have 0 ≤ disRG(u,v) ≤ n − 1, and disGR(u,v) = disG(u,v) if G is a tree. In Appendix E.2, we further show that RD is highly related to the graph Laplacian and can be efficiently calculated.
Theorem 4.2. Let G = (VG,EG) and H = (VH,EH) be two graphs, and let χG and χH be the corresponding RD-WL color mapping. Then the following holds:
•	For any two nodes w ∈ VG and x ∈ VH, if χG(w) = χH(x), then w is a cut vertex if and only if x is a cut vertex.
•	If {{χG(w) : w ∈ VG}} = {{χH(w) : w ∈ VH}}, then BCVTree(G) ≃ BCVTree(H).
The form of Theorem 4.2 exactly parallels Theorem 4.1, which shows that RD-WL is fully expressive for vertex-biconnectivity. We give a proof of Theorem 4.1 in Appendix C.5. In particular, the proof of the second item is highly technical due to the challenges in analyzing the (complex) structure of the block cut-vertex tree. It also highlights that distinguishing non-isomorphic graphs that have different BCVTrees is much easier than the general case.
Combining Theorems 4.1 and 4.2 immediately yields the following corollary, showing that all biconnectivity problems can be solved within our proposed GD-WL framework.
Corollary 4.3. When using both SPD and RD (i.e., by setting dG(u,v) := (disG(u,v),disRG(u,v))), the corresponding GD-WL is fully expressive for both vertex-biconnectivity and edge-biconnectivity.
Computational cost. The GD-WL framework only needs a complexity of Θ(n) space and Θ(n2) time per-iteration for a graph of n nodes and m edges, both of which are strictly less than DSS-WL. In particular, GD-WL has the same space complexity as 1-WL, which can be crucial for large-scale tasks. On the other hand, one may ask how much computational overhead there is in preprocessing pairwise distances between nodes. We show in Appendix E that the computational cost can be trivially upper bounded by O(nm) for SPD and O(n3) for RD. Note that the preprocessing step only needs to be executed once, and we find that the cost is negligible compared to the GNN architecture.
Practical implementation. One of the main advantages of GD-WL is its high degree of parallelizability. In particular, we find GD-WL can be easily implemented using a Transformer-like architecture by injecting distance information into Multi-head Attention (Vaswani et al., 2017), similar to the structural encoding in Graphormer (Ying et al., 2021a). The attention layer can be written as:
	Y softmax XWQh (XW XWVh ,	(5)
where X ∈ Rn×d is the input node features of the previous layer, D ∈ Rn×n is the distance matrix such that  are learnable weight matrices of the h-th head,  and  are elementwise functions applied to D (possibly parameterized), and ⊙ denotes the elementwise multiplication. The results Yh ∈ Rn×dH across all heads h are then combined and projected to obtain the final output Y = Ph YhWOh where WOh ∈ RdH×d. We call the resulting architecture Graphormer-GD, and the full structure of Graphormer-GD is provided in Appendix E.3.
It is easy to see that the mapping from X to Y in (5) is equivariant and simulates the GD-WL aggregation. Importantly, we have the following expressivity result, which precisely characterizes the power and limits of Graphormer-GD. We give a proof in Appendix E.3.
Theorem 4.4. Graphormer-GD is at most as powerful as GD-WL in distinguishing non-isomorphic graphs. Moreover, when choosing proper functions  and and using a sufficiently large number of heads and layers, Graphormer-GD is as powerful as GD-WL.
On the expressivity upper bound of GD-WL. To complete the theoretical analysis, we finally provide an upper bound of the expressive power for our proposed SPD-WL and RD-WL, by studying the relationship with the standard 2-FWL (3-WL) algorithm.
Theorem 4.5. The 2-FWL algorithm is more powerful than both SPD-WL and RD-WL. Formally, the 2-FWL color mapping induces a finer vertex partition than that of both SPD-WL and RD-WL.
We give a proof in Appendix C.6. Using Theorem 4.5, we arrive at the important corollary:
Corollary 4.6. The 2-FWL is fully expressive for both vertex-biconnectivity and edge-biconnectivity.
A worst-case analysis of GD-WL for distance-regular graphs. Since GD-WL heavily relies on distance information, one may wonder about its expressiveness in the worst-case scenario where distance information may not help distinguish certain non-isomorphic graphs, in particular, the class of distance-regular graphs (Brouwer et al., 1989). Due to space limit, we provide a comprehensive study of this question in Appendix C.7, where we give a precise and complete characterization of what types of distance-regular graphs SPD-WL/RD-WL/2-FWL can distinguish (with both theoretical results and counterexamples). The main result is present as follows:
Theorem 4.7. RD-WL is strictly more powerful than SPD-WL in distinguishing non-isomorphic distance-regular graphs. Moreover, RD-WL is as powerful as 2-FWL in distinguishing nonisomorphic distance-regular graphs.
The above theorem strongly justifies the power of resistance distance and our proposed GD-WL. Importantly, to our knowledge, this is the first result showing that a more efficient WL algorithm can match the expressive power of 2-FWL in distinguishing distance-regular graphs.

5	EXPERIMENTS
In this section, we perform empirical evaluations of our proposed Graphormer-GD. We mainly consider the following two sets of experiments. Firstly, we would like to verify whether GraphormerGD can indeed learn biconnectivity-related metrics easily as our theory predicts. Secondly, we would like to investigate whether GNNs with sufficient expressiveness for biconnectivity can also help real-world tasks and benefit the generalization performance as well. The code and models will be made publicly available at https://github.com/lsj2408/Graphormer-GD.


Synthetic tasks. To test the expressive power of GNNs for biconnectivity metrics, we separately consider two tasks: (i) Cut Vertex Detection and (ii) Cut Edge Detection. Given a GNN model that outputs node features, we add a learnable prediction head that takes each node feature (or two node features corresponding to each edge) as input and predicts whether it is a cut vertex (cut edge) or not. The evaluation metric for both tasks is the graph-level accuracy, i.e., given a graph, the model prediction is considered correct only when all the cut vertices/edges are correctly identified. To make the results convincing, we construct a challenging dataset that comprises various types of hard graphs, including the regular graphs with cut vertices/edges and also Examples C.9 and C.10 mentioned in Section 3. We also choose several GNN baselines with different levels of expressive power: (i) classic MPNNs (Kipf & Welling, 2017; Velickoviˇ c et al.´ , 2018; Xu et al., 2019); (ii) Graph Substructure Network (Bouritsas et al., 2022); (iii) Graphormer (Ying et al., 2021a). The details of model configurations, dataset, and training procedure are provided in Appendix F.1.
The results are presented in Table 2. It can be seen that baseline GNNs cannot perfectly solve these synthetic tasks. In contrast, the Graphormer-GD achieves 100% accuracy on both tasks, implying that it can easily learn biconnectivity metrics even in very difficult graphs. Moreover, while using only SPD suffices to identify cut edges, it is still necessary to further incorporate RD to identify cut vertices. This is consistent with our theoretical results in Theorems 4.1, 4.2 and 4.4.
Real-world tasks. We further study the empirical performance of our Graphormer-GD on the realworld benchmark: ZINC from Benchmarking-GNNs (Dwivedi et al., 2020). To show the scalability of Graphormer-GD, we train our models on both ZINC-Full (consisting of 250K molecular graphs) and ZINC-Subset (12K selected graphs). We comprehensively compare our model with prior exTable 3: Mean Absolute Error (MAE) on ZINC test set. Following Dwivedi et al. (2020), the parameter budget of compared models is set to 500k. We use ∗ to indicate the best performance pressive GNNs that have been publicly released. For a fair comparison, we ensure that the parameter budget of both Graphormer-GD and other compared models are around 500K, following Dwivedi et al. (2020). Details of baselines and settings are presented in Appendix F.2.
The results are shown in Table 3, where our score is averaged over four experiments with different seeds. We also list the per-epoch training time of different models on ZINC-subset as well as their model parameters. It can be seen that Graphormer-GD surpasses or matches all competitive baselines on the test set of both ZINC-Subset and ZINC-Full. Furthermore, we find that the empirical performance of compared models align with their expressive power measured by graph biconnectivity. For example, Subgraph GNNs that are expressive for biconnectivity also consistently outperform classic MPNNs by a large margin. Compared with Subgraph GNNs, the main advantage of Graphormer-GD is that it is simpler to implement, has stronger parallelizability, while still achieving better performance. Therefore, we believe our proposed architecture is both effective and efficient and can be well extended to more practical scenarios like drug discovery.
Other tasks. We also perform node-level experiments on two popular datasets: the Brazil-Airports and the Europe-Airports. Due to space limit, the results are shown in Appendix F.3.

6	CONCLUSION
In this paper, we systematically investigate the expressive power of GNNs via the perspective of graph biconnectivity. Through the novel lens, we gain strong theoretical insights into the power and limits of existing popular GNNs. We then introduce the principled GD-WL framework that is fully expressive for all biconnectivity metrics. We further design the Graphormer-GD architecture that is provably powerful while enjoying practical efficiency and parallelizability. Experiments on both synthetic and real-world datasets demonstrate the effectiveness of Graphormer-GD.
There are still many promising directions that have not yet been explored. Firstly, it remains an important open problem whether biconnectivity can be solved more efficiently in o(n2) time using equivariant GNNs. Secondly, a deep understanding of GD-WL is generally lacking. For example, we conjecture that RD-WL can encode graph spectral (Lim et al., 2022) and is strictly more powerful than SPD-WL in distinguishing general graphs. Thirdly, it may be interesting to further investigate more expressive distance (structural) encoding schemes beyond RD-WL and explore how to encode them in Graph Transformers. Finally, one can extend biconnectivity to a hierarchy of higher-order variants (e.g., tri-connectivity), which provides a completely different view parallel to the WL hierarchy to study the expressive power and guide designing provably powerful GNNs architectures.
ACKNOWLEDGMENTS
Bohang Zhang is grateful to Ruichen Li for his great help in discussing and checking several of the main results in this paper, including Theorems 3.1, 3.2, 4.1 and 4.7. In particular, after the initial submission, Ruichen Li discovered a simpler proof of Lemma C.28 and helped complete the proof of Theorem C.61. Bohang Zhang would also thank Yiheng Du, Kai Yang amd Ruichen Li for correcting some small mistakes in the proof of Lemmas C.20 and C.45.


